<?xml version="1.0" encoding="utf-8"?>
<Namespace DisplayName="::vl::workflow::analyzer">
  <Overloads DisplayName="BuildGlobalNameFromModules function">
    <Symbol Key="::vl::workflow::analyzer::BuildGlobalNameFromModules(* WfLexicalScopeManager)" UrlName="vl.workflow.analyzer.BuildGlobalNameFromModules(^ WfLexicalScopeManager)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="BuildGlobalNameFromTypeDescriptors function">
    <Symbol Key="::vl::workflow::analyzer::BuildGlobalNameFromTypeDescriptors(* WfLexicalScopeManager)" UrlName="vl.workflow.analyzer.BuildGlobalNameFromTypeDescriptors(^ WfLexicalScopeManager)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="BuildNameForDeclaration function">
    <Symbol Key="::vl::workflow::analyzer::BuildNameForDeclaration(* WfLexicalScopeManager,Ptr&lt;WfLexicalScopeName&gt;,* WfDeclaration)" UrlName="vl.workflow.analyzer.BuildNameForDeclaration(^ WfLexicalScopeManager,Ptr{WfLexicalScopeName},^ WfDeclaration)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="BuildScopeForDeclaration function">
    <Symbol Key="::vl::workflow::analyzer::BuildScopeForDeclaration(* WfLexicalScopeManager,Ptr&lt;WfLexicalScope&gt;,Ptr&lt;WfDeclaration&gt;,* parsing::ParsingTreeCustomBase,Ptr&lt;WfClassMember&gt;)" UrlName="vl.workflow.analyzer.BuildScopeForDeclaration(^ WfLexicalScopeManager,Ptr{WfLexicalScope},Ptr{WfDeclaration},^ parsing.ParsingTreeCustomBase,Ptr{WfClassMember})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="BuildScopeForExpression function">
    <Symbol Key="::vl::workflow::analyzer::BuildScopeForExpression(* WfLexicalScopeManager,Ptr&lt;WfLexicalScope&gt;,Ptr&lt;WfExpression&gt;)" UrlName="vl.workflow.analyzer.BuildScopeForExpression(^ WfLexicalScopeManager,Ptr{WfLexicalScope},Ptr{WfExpression})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="BuildScopeForModule function">
    <Symbol Key="::vl::workflow::analyzer::BuildScopeForModule(* WfLexicalScopeManager,Ptr&lt;WfModule&gt;)" UrlName="vl.workflow.analyzer.BuildScopeForModule(^ WfLexicalScopeManager,Ptr{WfModule})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="BuildScopeForStatement function">
    <Symbol Key="::vl::workflow::analyzer::BuildScopeForStatement(* WfLexicalScopeManager,Ptr&lt;WfLexicalScope&gt;,Ptr&lt;WfStatement&gt;)" UrlName="vl.workflow.analyzer.BuildScopeForStatement(^ WfLexicalScopeManager,Ptr{WfLexicalScope},Ptr{WfStatement})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CanConvertToType function">
    <Symbol Key="::vl::workflow::analyzer::CanConvertToType(* reflection::description::ITypeInfo,* reflection::description::ITypeInfo,bool)" UrlName="vl.workflow.analyzer.CanConvertToType(^ reflection.description.ITypeInfo,^ reflection.description.ITypeInfo,bool)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CheckScopes_BaseType function">
    <Symbol Key="::vl::workflow::analyzer::CheckScopes_BaseType(* WfLexicalScopeManager)" UrlName="vl.workflow.analyzer.CheckScopes_BaseType(^ WfLexicalScopeManager)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CheckScopes_DuplicatedSymbol function">
    <Symbol Key="::vl::workflow::analyzer::CheckScopes_DuplicatedSymbol(* WfLexicalScopeManager)" UrlName="vl.workflow.analyzer.CheckScopes_DuplicatedSymbol(^ WfLexicalScopeManager)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CheckScopes_SymbolType function">
    <Symbol Key="::vl::workflow::analyzer::CheckScopes_SymbolType(* WfLexicalScopeManager)" UrlName="vl.workflow.analyzer.CheckScopes_SymbolType(^ WfLexicalScopeManager)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="Compile function">
    <Symbol Key="::vl::workflow::analyzer::Compile(Ptr&lt;parsing::tabling::ParsingTable&gt;,* WfLexicalScopeManager,&amp; collections::List&lt;WString&gt;,&amp; collections::List&lt;Ptr&lt;parsing::ParsingError&gt;&gt;)" UrlName="vl.workflow.analyzer.Compile(Ptr{parsing.tabling.ParsingTable},^ WfLexicalScopeManager,&amp; collections.List{WString},&amp; collections.List{Ptr{parsing.ParsingError}})" Doc="true" />
    <Symbol Key="::vl::workflow::analyzer::Compile(Ptr&lt;parsing::tabling::ParsingTable&gt;,&amp; collections::List&lt;WString&gt;,&amp; collections::List&lt;Ptr&lt;parsing::ParsingError&gt;&gt;)" UrlName="vl.workflow.analyzer.Compile(Ptr{parsing.tabling.ParsingTable},&amp; collections.List{WString},&amp; collections.List{Ptr{parsing.ParsingError}})" Doc="true" />
  </Overloads>
  <Overloads DisplayName="CompleteScopeForClassMember function">
    <Symbol Key="::vl::workflow::analyzer::CompleteScopeForClassMember(* WfLexicalScopeManager,Ptr&lt;typeimpl::WfCustomType&gt;,Ptr&lt;WfClassDeclaration&gt;,Ptr&lt;WfClassMember&gt;)" UrlName="vl.workflow.analyzer.CompleteScopeForClassMember(^ WfLexicalScopeManager,Ptr{typeimpl.WfCustomType},Ptr{WfClassDeclaration},Ptr{WfClassMember})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CompleteScopeForDeclaration function">
    <Symbol Key="::vl::workflow::analyzer::CompleteScopeForDeclaration(* WfLexicalScopeManager,Ptr&lt;WfDeclaration&gt;)" UrlName="vl.workflow.analyzer.CompleteScopeForDeclaration(^ WfLexicalScopeManager,Ptr{WfDeclaration})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CompleteScopeForModule function">
    <Symbol Key="::vl::workflow::analyzer::CompleteScopeForModule(* WfLexicalScopeManager,Ptr&lt;WfModule&gt;)" UrlName="vl.workflow.analyzer.CompleteScopeForModule(^ WfLexicalScopeManager,Ptr{WfModule})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CopyAttribute function">
    <Symbol Key="::vl::workflow::analyzer::CopyAttribute(Ptr&lt;WfAttribute&gt;)" UrlName="vl.workflow.analyzer.CopyAttribute(Ptr{WfAttribute})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CopyAttributes function">
    <Symbol Key="::vl::workflow::analyzer::CopyAttributes(&amp; collections::List&lt;Ptr&lt;WfAttribute&gt;&gt;,&amp; collections::List&lt;Ptr&lt;WfAttribute&gt;&gt;)" UrlName="vl.workflow.analyzer.CopyAttributes(&amp; collections.List{Ptr{WfAttribute}},&amp; collections.List{Ptr{WfAttribute}})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CopyDeclaration function">
    <Symbol Key="::vl::workflow::analyzer::CopyDeclaration(Ptr&lt;WfDeclaration&gt;)" UrlName="vl.workflow.analyzer.CopyDeclaration(Ptr{WfDeclaration})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CopyExpression function">
    <Symbol Key="::vl::workflow::analyzer::CopyExpression(Ptr&lt;WfExpression&gt;)" UrlName="vl.workflow.analyzer.CopyExpression(Ptr{WfExpression})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CopyStatement function">
    <Symbol Key="::vl::workflow::analyzer::CopyStatement(Ptr&lt;WfStatement&gt;)" UrlName="vl.workflow.analyzer.CopyStatement(Ptr{WfStatement})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CopyType function">
    <Symbol Key="::vl::workflow::analyzer::CopyType(Ptr&lt;WfType&gt;)" UrlName="vl.workflow.analyzer.CopyType(Ptr{WfType})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CopyTypeInfo function">
    <Symbol Key="::vl::workflow::analyzer::CopyTypeInfo(* reflection::description::ITypeInfo)" UrlName="vl.workflow.analyzer.CopyTypeInfo(^ reflection.description.ITypeInfo)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CreateTypeInfoFromMethodInfo function">
    <Symbol Key="::vl::workflow::analyzer::CreateTypeInfoFromMethodInfo(* reflection::description::IMethodInfo)" UrlName="vl.workflow.analyzer.CreateTypeInfoFromMethodInfo(^ reflection.description.IMethodInfo)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CreateTypeInfoFromType function">
    <Symbol Key="::vl::workflow::analyzer::CreateTypeInfoFromType(* WfLexicalScope,Ptr&lt;WfType&gt;)" UrlName="vl.workflow.analyzer.CreateTypeInfoFromType(^ WfLexicalScope,Ptr{WfType})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="CreateTypeInfoFromTypeFlag function">
    <Symbol Key="::vl::workflow::analyzer::CreateTypeInfoFromTypeFlag(TypeFlag)" UrlName="vl.workflow.analyzer.CreateTypeInfoFromTypeFlag(TypeFlag)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ExpandBindExpression function">
    <Symbol Key="::vl::workflow::analyzer::ExpandBindExpression(* WfLexicalScopeManager,* WfBindExpression)" UrlName="vl.workflow.analyzer.ExpandBindExpression(^ WfLexicalScopeManager,^ WfBindExpression)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ExpandObserveExpression function">
    <Symbol Key="::vl::workflow::analyzer::ExpandObserveExpression(* WfExpression,&amp; collections::Dictionary&lt;* WfExpression, WString&gt;,&amp; collections::Dictionary&lt;WString, WString&gt;,bool)" UrlName="vl.workflow.analyzer.ExpandObserveExpression(^ WfExpression,&amp; collections.Dictionary{^ WfExpression, WString},&amp; collections.Dictionary{WString, WString},bool)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GenerateAssembly function">
    <Symbol Key="::vl::workflow::analyzer::GenerateAssembly(* WfLexicalScopeManager)" UrlName="vl.workflow.analyzer.GenerateAssembly(^ WfLexicalScopeManager)" Doc="true" />
  </Overloads>
  <Overloads DisplayName="GenerateClosureInstructions function">
    <Symbol Key="::vl::workflow::analyzer::GenerateClosureInstructions(&amp; WfCodegenContext,Ptr&lt;WfCodegenFunctionContext&gt;)" UrlName="vl.workflow.analyzer.GenerateClosureInstructions(&amp; WfCodegenContext,Ptr{WfCodegenFunctionContext})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GenerateDeclarationInstructions function">
    <Symbol Key="::vl::workflow::analyzer::GenerateDeclarationInstructions(&amp; WfCodegenContext,Ptr&lt;WfDeclaration&gt;)" UrlName="vl.workflow.analyzer.GenerateDeclarationInstructions(&amp; WfCodegenContext,Ptr{WfDeclaration})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GenerateExpressionInstructions function">
    <Symbol Key="::vl::workflow::analyzer::GenerateExpressionInstructions(&amp; WfCodegenContext,Ptr&lt;WfExpression&gt;,Ptr&lt;reflection::description::ITypeInfo&gt;)" UrlName="vl.workflow.analyzer.GenerateExpressionInstructions(&amp; WfCodegenContext,Ptr{WfExpression},Ptr{reflection.description.ITypeInfo})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GenerateFunctionDeclarationMetadata function">
    <Symbol Key="::vl::workflow::analyzer::GenerateFunctionDeclarationMetadata(&amp; WfCodegenContext,* WfFunctionDeclaration,Ptr&lt;runtime::WfAssemblyFunction&gt;)" UrlName="vl.workflow.analyzer.GenerateFunctionDeclarationMetadata(&amp; WfCodegenContext,^ WfFunctionDeclaration,Ptr{runtime.WfAssemblyFunction})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GenerateGlobalDeclarationMetadata function">
    <Symbol Key="::vl::workflow::analyzer::GenerateGlobalDeclarationMetadata(&amp; WfCodegenContext,Ptr&lt;WfDeclaration&gt;,&amp; const WString)" UrlName="vl.workflow.analyzer.GenerateGlobalDeclarationMetadata(&amp; WfCodegenContext,Ptr{WfDeclaration},&amp; const WString)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GenerateInitializeInstructions function">
    <Symbol Key="::vl::workflow::analyzer::GenerateInitializeInstructions(&amp; WfCodegenContext,Ptr&lt;WfDeclaration&gt;)" UrlName="vl.workflow.analyzer.GenerateInitializeInstructions(&amp; WfCodegenContext,Ptr{WfDeclaration})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GenerateStatementInstructions function">
    <Symbol Key="::vl::workflow::analyzer::GenerateStatementInstructions(&amp; WfCodegenContext,Ptr&lt;WfStatement&gt;)" UrlName="vl.workflow.analyzer.GenerateStatementInstructions(&amp; WfCodegenContext,Ptr{WfStatement})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GenerateTypeCastInstructions function">
    <Symbol Key="::vl::workflow::analyzer::GenerateTypeCastInstructions(&amp; WfCodegenContext,Ptr&lt;reflection::description::ITypeInfo&gt;,bool,* WfExpression)" UrlName="vl.workflow.analyzer.GenerateTypeCastInstructions(&amp; WfCodegenContext,Ptr{reflection.description.ITypeInfo},bool,^ WfExpression)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GenerateTypeTestingInstructions function">
    <Symbol Key="::vl::workflow::analyzer::GenerateTypeTestingInstructions(&amp; WfCodegenContext,Ptr&lt;reflection::description::ITypeInfo&gt;,* WfExpression)" UrlName="vl.workflow.analyzer.GenerateTypeTestingInstructions(&amp; WfCodegenContext,Ptr{reflection.description.ITypeInfo},^ WfExpression)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GetEnumerableExpressionItemType function">
    <Symbol Key="::vl::workflow::analyzer::GetEnumerableExpressionItemType(* WfLexicalScopeManager,Ptr&lt;WfExpression&gt;,Ptr&lt;reflection::description::ITypeInfo&gt;)" UrlName="vl.workflow.analyzer.GetEnumerableExpressionItemType(^ WfLexicalScopeManager,Ptr{WfExpression},Ptr{reflection.description.ITypeInfo})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GetExpressionEventInfo function">
    <Symbol Key="::vl::workflow::analyzer::GetExpressionEventInfo(* WfLexicalScopeManager,Ptr&lt;WfExpression&gt;)" UrlName="vl.workflow.analyzer.GetExpressionEventInfo(^ WfLexicalScopeManager,Ptr{WfExpression})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GetExpressionName function">
    <Symbol Key="::vl::workflow::analyzer::GetExpressionName(Ptr&lt;WfExpression&gt;)" UrlName="vl.workflow.analyzer.GetExpressionName(Ptr{WfExpression})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GetExpressionScopeName function">
    <Symbol Key="::vl::workflow::analyzer::GetExpressionScopeName(* WfLexicalScopeManager,Ptr&lt;WfExpression&gt;)" UrlName="vl.workflow.analyzer.GetExpressionScopeName(^ WfLexicalScopeManager,Ptr{WfExpression})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GetExpressionType function">
    <Symbol Key="::vl::workflow::analyzer::GetExpressionType(* WfLexicalScopeManager,Ptr&lt;WfExpression&gt;,Ptr&lt;reflection::description::ITypeInfo&gt;)" UrlName="vl.workflow.analyzer.GetExpressionType(^ WfLexicalScopeManager,Ptr{WfExpression},Ptr{reflection.description.ITypeInfo})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GetExpressionTypes function">
    <Symbol Key="::vl::workflow::analyzer::GetExpressionTypes(* WfLexicalScopeManager,Ptr&lt;WfExpression&gt;,Ptr&lt;reflection::description::ITypeInfo&gt;,bool,&amp; collections::List&lt;ResolveExpressionResult&gt;)" UrlName="vl.workflow.analyzer.GetExpressionTypes(^ WfLexicalScopeManager,Ptr{WfExpression},Ptr{reflection.description.ITypeInfo},bool,&amp; collections.List{ResolveExpressionResult})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GetInstructionTypeArgument function">
    <Symbol Key="::vl::workflow::analyzer::GetInstructionTypeArgument(Ptr&lt;reflection::description::ITypeInfo&gt;)" UrlName="vl.workflow.analyzer.GetInstructionTypeArgument(Ptr{reflection.description.ITypeInfo})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GetLeftValueExpressionType function">
    <Symbol Key="::vl::workflow::analyzer::GetLeftValueExpressionType(* WfLexicalScopeManager,Ptr&lt;WfExpression&gt;)" UrlName="vl.workflow.analyzer.GetLeftValueExpressionType(^ WfLexicalScopeManager,Ptr{WfExpression})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GetMergedType function">
    <Symbol Key="::vl::workflow::analyzer::GetMergedType(Ptr&lt;reflection::description::ITypeInfo&gt;,Ptr&lt;reflection::description::ITypeInfo&gt;)" UrlName="vl.workflow.analyzer.GetMergedType(Ptr{reflection.description.ITypeInfo},Ptr{reflection.description.ITypeInfo})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GetObservingDependency function">
    <Symbol Key="::vl::workflow::analyzer::GetObservingDependency(* WfLexicalScopeManager,Ptr&lt;WfExpression&gt;,&amp; WfObservingDependency)" UrlName="vl.workflow.analyzer.GetObservingDependency(^ WfLexicalScopeManager,Ptr{WfExpression},&amp; WfObservingDependency)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GetScopeNameFromReferenceType function">
    <Symbol Key="::vl::workflow::analyzer::GetScopeNameFromReferenceType(* WfLexicalScope,Ptr&lt;WfType&gt;)" UrlName="vl.workflow.analyzer.GetScopeNameFromReferenceType(^ WfLexicalScope,Ptr{WfType})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GetTypeFlag function">
    <Symbol Key="::vl::workflow::analyzer::GetTypeFlag(* reflection::description::ITypeDescriptor)" UrlName="vl.workflow.analyzer.GetTypeFlag(^ reflection.description.ITypeDescriptor)" Doc="false" />
    <Symbol Key="::vl::workflow::analyzer::GetTypeFlag(* reflection::description::ITypeInfo)" UrlName="vl.workflow.analyzer.GetTypeFlag(^ reflection.description.ITypeInfo)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="GetTypeFromTypeInfo function">
    <Symbol Key="::vl::workflow::analyzer::GetTypeFromTypeInfo(* reflection::description::ITypeInfo)" UrlName="vl.workflow.analyzer.GetTypeFromTypeInfo(^ reflection.description.ITypeInfo)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="IsExpressionDependOnExpectedType function">
    <Symbol Key="::vl::workflow::analyzer::IsExpressionDependOnExpectedType(* WfLexicalScopeManager,Ptr&lt;WfExpression&gt;)" UrlName="vl.workflow.analyzer.IsExpressionDependOnExpectedType(^ WfLexicalScopeManager,Ptr{WfExpression})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="IsNullAcceptableType function">
    <Symbol Key="::vl::workflow::analyzer::IsNullAcceptableType(* reflection::description::ITypeInfo)" UrlName="vl.workflow.analyzer.IsNullAcceptableType(^ reflection.description.ITypeInfo)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="IsSameType function">
    <Symbol Key="::vl::workflow::analyzer::IsSameType(* reflection::description::ITypeInfo,* reflection::description::ITypeInfo)" UrlName="vl.workflow.analyzer.IsSameType(^ reflection.description.ITypeInfo,^ reflection.description.ITypeInfo)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ResolveExpressionResult struct">
    <Symbol Key="::vl::workflow::analyzer::ResolveExpressionResult" UrlName="vl.workflow.analyzer.ResolveExpressionResult" Doc="false" />
  </Overloads>
  <Overloads DisplayName="SearchOrderedName function">
    <Symbol Key="::vl::workflow::analyzer::SearchOrderedName(* WfLexicalScope,Ptr&lt;WfDeclaration&gt;,&amp; collections::SortedList&lt;vint&gt;)" UrlName="vl.workflow.analyzer.SearchOrderedName(^ WfLexicalScope,Ptr{WfDeclaration},&amp; collections.SortedList{vint})" Doc="false" />
    <Symbol Key="::vl::workflow::analyzer::SearchOrderedName(* WfLexicalScope,Ptr&lt;WfStatement&gt;,&amp; collections::SortedList&lt;vint&gt;)" UrlName="vl.workflow.analyzer.SearchOrderedName(^ WfLexicalScope,Ptr{WfStatement},&amp; collections.SortedList{vint})" Doc="false" />
    <Symbol Key="::vl::workflow::analyzer::SearchOrderedName(* WfLexicalScope,Ptr&lt;WfExpression&gt;,&amp; collections::SortedList&lt;vint&gt;)" UrlName="vl.workflow.analyzer.SearchOrderedName(^ WfLexicalScope,Ptr{WfExpression},&amp; collections.SortedList{vint})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="TypeFlag enum">
    <Symbol Key="::vl::workflow::analyzer::TypeFlag" UrlName="vl.workflow.analyzer.TypeFlag" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateClassMemberSemantic function">
    <Symbol Key="::vl::workflow::analyzer::ValidateClassMemberSemantic(* WfLexicalScopeManager,Ptr&lt;typeimpl::WfCustomType&gt;,Ptr&lt;WfClassDeclaration&gt;,Ptr&lt;WfClassMember&gt;)" UrlName="vl.workflow.analyzer.ValidateClassMemberSemantic(^ WfLexicalScopeManager,Ptr{typeimpl.WfCustomType},Ptr{WfClassDeclaration},Ptr{WfClassMember})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateConstantExpression function">
    <Symbol Key="::vl::workflow::analyzer::ValidateConstantExpression(* WfLexicalScopeManager,Ptr&lt;WfExpression&gt;,Ptr&lt;reflection::description::ITypeInfo&gt;)" UrlName="vl.workflow.analyzer.ValidateConstantExpression(^ WfLexicalScopeManager,Ptr{WfExpression},Ptr{reflection.description.ITypeInfo})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateDeclarationSemantic function">
    <Symbol Key="::vl::workflow::analyzer::ValidateDeclarationSemantic(* WfLexicalScopeManager,Ptr&lt;WfDeclaration&gt;)" UrlName="vl.workflow.analyzer.ValidateDeclarationSemantic(^ WfLexicalScopeManager,Ptr{WfDeclaration})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateDeclarationStructure function">
    <Symbol Key="::vl::workflow::analyzer::ValidateDeclarationStructure(* WfLexicalScopeManager,Ptr&lt;WfDeclaration&gt;,* WfClassDeclaration,* parsing::ParsingTreeCustomBase)" UrlName="vl.workflow.analyzer.ValidateDeclarationStructure(^ WfLexicalScopeManager,Ptr{WfDeclaration},^ WfClassDeclaration,^ parsing.ParsingTreeCustomBase)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateExpressionSemantic function">
    <Symbol Key="::vl::workflow::analyzer::ValidateExpressionSemantic(* WfLexicalScopeManager,Ptr&lt;WfExpression&gt;,Ptr&lt;reflection::description::ITypeInfo&gt;,&amp; collections::List&lt;ResolveExpressionResult&gt;)" UrlName="vl.workflow.analyzer.ValidateExpressionSemantic(^ WfLexicalScopeManager,Ptr{WfExpression},Ptr{reflection.description.ITypeInfo},&amp; collections.List{ResolveExpressionResult})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateExpressionStructure function">
    <Symbol Key="::vl::workflow::analyzer::ValidateExpressionStructure(* WfLexicalScopeManager,* ValidateStructureContext,&amp; Ptr&lt;WfExpression&gt;)" UrlName="vl.workflow.analyzer.ValidateExpressionStructure(^ WfLexicalScopeManager,^ ValidateStructureContext,&amp; Ptr{WfExpression})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateModuleSemantic function">
    <Symbol Key="::vl::workflow::analyzer::ValidateModuleSemantic(* WfLexicalScopeManager,Ptr&lt;WfModule&gt;)" UrlName="vl.workflow.analyzer.ValidateModuleSemantic(^ WfLexicalScopeManager,Ptr{WfModule})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateModuleStructure function">
    <Symbol Key="::vl::workflow::analyzer::ValidateModuleStructure(* WfLexicalScopeManager,Ptr&lt;WfModule&gt;)" UrlName="vl.workflow.analyzer.ValidateModuleStructure(^ WfLexicalScopeManager,Ptr{WfModule})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateScopeName function">
    <Symbol Key="::vl::workflow::analyzer::ValidateScopeName(* WfLexicalScopeManager,Ptr&lt;WfLexicalScopeName&gt;)" UrlName="vl.workflow.analyzer.ValidateScopeName(^ WfLexicalScopeManager,Ptr{WfLexicalScopeName})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateStatementSemantic function">
    <Symbol Key="::vl::workflow::analyzer::ValidateStatementSemantic(* WfLexicalScopeManager,Ptr&lt;WfStatement&gt;)" UrlName="vl.workflow.analyzer.ValidateStatementSemantic(^ WfLexicalScopeManager,Ptr{WfStatement})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateStatementStructure function">
    <Symbol Key="::vl::workflow::analyzer::ValidateStatementStructure(* WfLexicalScopeManager,* ValidateStructureContext,&amp; Ptr&lt;WfStatement&gt;)" UrlName="vl.workflow.analyzer.ValidateStatementStructure(^ WfLexicalScopeManager,^ ValidateStructureContext,&amp; Ptr{WfStatement})" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateStructureContext struct">
    <Symbol Key="::vl::workflow::analyzer::ValidateStructureContext" UrlName="vl.workflow.analyzer.ValidateStructureContext" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateTypeStragety enum">
    <Symbol Key="::vl::workflow::analyzer::ValidateTypeStragety" UrlName="vl.workflow.analyzer.ValidateTypeStragety" Doc="false" />
  </Overloads>
  <Overloads DisplayName="ValidateTypeStructure function">
    <Symbol Key="::vl::workflow::analyzer::ValidateTypeStructure(* WfLexicalScopeManager,Ptr&lt;WfType&gt;,ValidateTypeStragety,* WfClassDeclaration)" UrlName="vl.workflow.analyzer.ValidateTypeStructure(^ WfLexicalScopeManager,Ptr{WfType},ValidateTypeStragety,^ WfClassDeclaration)" Doc="false" />
  </Overloads>
  <Overloads DisplayName="WfCodegenContext class">
    <Symbol Key="::vl::workflow::analyzer::WfCodegenContext" UrlName="vl.workflow.analyzer.WfCodegenContext" Doc="false" />
  </Overloads>
  <Overloads DisplayName="WfCodegenFunctionContext class">
    <Symbol Key="::vl::workflow::analyzer::WfCodegenFunctionContext" UrlName="vl.workflow.analyzer.WfCodegenFunctionContext" Doc="false" />
  </Overloads>
  <Overloads DisplayName="WfCodegenLambdaContext struct">
    <Symbol Key="::vl::workflow::analyzer::WfCodegenLambdaContext" UrlName="vl.workflow.analyzer.WfCodegenLambdaContext" Doc="false" />
  </Overloads>
  <Overloads DisplayName="WfCodegenScopeContext class">
    <Symbol Key="::vl::workflow::analyzer::WfCodegenScopeContext" UrlName="vl.workflow.analyzer.WfCodegenScopeContext" Doc="false" />
  </Overloads>
  <Overloads DisplayName="WfCodegenScopeType enum">
    <Symbol Key="::vl::workflow::analyzer::WfCodegenScopeType" UrlName="vl.workflow.analyzer.WfCodegenScopeType" Doc="false" />
  </Overloads>
  <Overloads DisplayName="WfErrors struct">
    <Symbol Key="::vl::workflow::analyzer::WfErrors" UrlName="vl.workflow.analyzer.WfErrors" Doc="false" />
  </Overloads>
  <Overloads DisplayName="WfLexicalCapture struct">
    <Symbol Key="::vl::workflow::analyzer::WfLexicalCapture" UrlName="vl.workflow.analyzer.WfLexicalCapture" Doc="false" />
  </Overloads>
  <Overloads DisplayName="WfLexicalFunctionConfig class">
    <Symbol Key="::vl::workflow::analyzer::WfLexicalFunctionConfig" UrlName="vl.workflow.analyzer.WfLexicalFunctionConfig" Doc="false" />
  </Overloads>
  <Overloads DisplayName="WfLexicalScope class">
    <Symbol Key="::vl::workflow::analyzer::WfLexicalScope" UrlName="vl.workflow.analyzer.WfLexicalScope" Doc="false" />
  </Overloads>
  <Overloads DisplayName="WfLexicalScopeManager class">
    <Symbol Key="::vl::workflow::analyzer::WfLexicalScopeManager" UrlName="vl.workflow.analyzer.WfLexicalScopeManager" Doc="true" />
  </Overloads>
  <Overloads DisplayName="WfLexicalScopeName class">
    <Symbol Key="::vl::workflow::analyzer::WfLexicalScopeName" UrlName="vl.workflow.analyzer.WfLexicalScopeName" Doc="false" />
  </Overloads>
  <Overloads DisplayName="WfLexicalSymbol class">
    <Symbol Key="::vl::workflow::analyzer::WfLexicalSymbol" UrlName="vl.workflow.analyzer.WfLexicalSymbol" Doc="false" />
  </Overloads>
  <Overloads DisplayName="WfObservingDependency class">
    <Symbol Key="::vl::workflow::analyzer::WfObservingDependency" UrlName="vl.workflow.analyzer.WfObservingDependency" Doc="false" />
  </Overloads>
</Namespace>